---
title: include file
description: Provides a quickstart on how to use Call Automation JavaScript SDK to build call flow for customer interactions.
services: azure-communication-services
author: richardcho

ms.service: azure-communication-services
ms.subservice: call-automation
ms.date: 06/08/2023
ms.topic: include
ms.custom: include file
ms.author: richardcho
---

## Prerequisites

- An Azure account with an active subscription.
- Azure Communication Services resource. See [Create an Azure Communication Services resource](../../create-communication-resource.md?tabs=windows&pivots=platform-azp). Note the resource connection string for this quickstart by navigating to your resource selecting 'Keys' from the left side menu.
- [Acquire a phone number for your Communication Service resource](../../telephony/get-phone-number.md?pivots=programming-language-csharp) or connect your carrier using [Azure direct routing](../../../concepts/telephony/direct-routing-infrastructure.md). Note the phone number you acquired or provisioned using Azure direct routing for use in this quickstart.
- The latest [nodejs](https://nodejs.org/en) for your operating system. latest stable LTS version is recommended. It's also recommended to use [TypeScript](https://www.npmjs.com/package/typescript) as `@azure/communication-call-automation` package provides all the necessary type declarations, but it's optional.
- An audio file for the message you want to play in the call. This audio should be accessible via a url.

## Create a new nodejs application

Create a new web application In the console window of your operating system.

```console
npm init
```

If using TypeScript, also install and initialize TypeScript.

```console
npm install typescript && \
node_modules/typescript/bin/tsc --init
```

## Install required packages

Install the following dependencies to your project. In this quickstart we use `express` as our web API framework.

```console
npm install @azure/communication-call-automation @azure/eventgrid express
```

If using TypeScript

```console
npm install --save-dev @types/express @types/node
```

## Set up a public URI for the local application

In this quick-start, we use [Ngrok tool](https://ngrok.com/) to project a public URI to the local port so that your local application can be visited by the internet. The public URI is needed to receive the Event Grid `IncomingCall` event and Call Automation events using webhooks.

First, decide the port for your application. `3000` is the default endpoint of an express app.

Then, [install Ngrok](https://ngrok.com/download) and run Ngrok with the following command: `ngrok http <port>`. This command creates a public URI like `https://ff2f-75-155-253-232.ngrok.io/`, and it is your Ngrok Fully Qualified Domain Name(Ngrok_FQDN). Keep Ngrok running while following the rest of this quick-start.

## Handle incoming calls

In this code snippet, /api/incomingCall is the default route that is used to listen for and answer incoming calls. At a later step, you register this url with Event Grid. Since Event Grid requires you to prove ownership of your Webhook endpoint before it starts delivering events to that endpoint, the code sample also handles this one time validation by processing SubscriptionValidationEvent. This requirement prevents a malicious user from flooding your endpoint with events. For more information, see this [guide](../../../../event-grid/webhook-event-delivery.md).  

The code sample also illustrates how you can control the callback URI by setting your own context/ID when you answer the call. All events generated by the call will be sent to the specific route you provide when answering an inbound call and the same applies to when you place an outbound call.  

Add the following snippet to `index.js`

``` JavaScript
import express from "express";
import { DtmfTone, parseCallAutomationEvent } from "@azure/communication-call-automation";
import { EventGridDeserializer } from "@azure/eventgrid";
import { createIdentifierFromRawId } from "@azure/communication-common";

const port = 3000;
const app = express();
const publicUri = "<ngrokPublicUrl>";
const connectionString = "<connectionStringOfCommunicationResource>";
const mediaUrl = "<linkToMediaFile>";
const phoneNumberToCall = "<phoneNumberToCall>" // in E.164 format
const applicationPhoneNumber = "<phoneNumberAcquiredAsPrerequisite>";
const { deserializeEventGridEvents } = new EventGridDeserializer();
const callAutomationClient = new CallAutomationClient(connectionString);

app.post("/api/incomingCall", async (req, res) => {
    try {
        const events = await deserializeEventGridEvents(req.body[0]);

        for (const { eventType, data } of events) {
            if (eventType === "Microsoft.EventGrid.SubscriptionValidationEvent") {
                if (!data?.validationCode) {
                    throw new Error("Unable to validate Event Grid subscription");
                }

                return res.status(200).send({ validationResponse: data.validationCode });
            }

            if (eventType === "Microsoft.Communication.IncomingCall") {
                const { incomingCallContext } = data;

                await callAutomationClient.answerCall(incomingCallContext, publicUri);
            }
        }

        return res.sendStatus(200);
    } catch (e) {
        return res.status(500).send(e);
    }
});

app.post("/api/calls", async (req, res) => {
    try {
        const { callConnectionId, kind } = parseCallAutomationEvent(req.body[0]);
        const rawId = req.query.callerId as string;

        if (kind === "CallConnected") {
            await callAutomationClient
                .getCallConnection(callConnectionId)
                .getCallMedia()
                .startRecognizing(
                    createIdentifierFromRawId(rawId),
                    3,
                    {
                        interruptPrompt: true,
                        interToneTimeoutInSeconds: 10,
                        initialSilenceTimeoutInSeconds: 5,
                        playPrompt: { url: mediaUrl, kind: "fileSource" },
                        stopDtmfTones: [DtmfTone.Pound],
                        operationContext: "MainMenu",
                        kind: "callMediaRecognizeDtmfOptions",
                    });
        }

        if (kind === "RecognizeCompleted") {
            await callAutomationClient
                .getCallConnection(callConnectionId)
                .addParticipant({
                    targetParticipant: { phoneNumber: phoneNumberToCall },
                    sourceCallIdNumber: { phoneNumber: applicationPhoneNumber }
                });
        }

        return res.sendStatus(200);
    } catch (e) {
        return res.sendStatus(500);
    }
});

app.use(express.json());
app.listen(port);
```

Replace the placeholders with the actual values.

## Run the app

Add `start` script to your node application.

```json
{
    "scripts": {
        "start": "node index.js"
    }
}
```

```console
npm start
```

If using TypeScript, also add a `build` script to transpile to JavaScript.

```json
{
    "scripts": {
        "build": "tsc",
        "start": "node index.js"
    }
}
```

```console
npm run build && npm start
```

## Configure Event Grid webhook subscription

In order to receive the `IncomingCall` event for the inbound PSTN call, you must configure an Event Grid subscription as described in this [concepts guide](../../../concepts/call-automation/incoming-call-notification.md). The most important thing to remember is that an Event Grid webhook subscription must be validated against a working web server. Since you've started the project in the previous step, and you have a public FQDN, set the webhook address in your subscription to your POST endpoint (`https://<ngrokPublicUrl>/api/incomingCall`).

Once your webhook subscription has been validated, it shows up in the portal and you're now ready to test your application by making an inbound call.
